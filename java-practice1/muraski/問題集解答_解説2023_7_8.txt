練習問題　回答
１－１　B
JDKは、様々なベンダから提供されており、有償のもの、無償のものが存在するため
ベンダによって有償、無償が異なるためAは誤り

１－２　D
2行目のコード public static void main(String args) {} の部分より、コンパイルはできるが実行時にエラーが発生する。
main()型のメソッドはString型を配列で受け取る必要があるため。
Java言語の文法としては誤りではないため、コンパイルができる。

１－３　B　C
import文は複数記述することができるため、また、package文とimport文の両方を記載する際は、package文を先に記述する必要があるため。
順番としてはpackage文 import文 クラス定義の順番
また、package文は先頭１行目にしか記述できない。

１－４　B
import java.util.*;はjava.utilのすべてのクラスをインポートする記述のため

１－５	D
MainクラスではSampleクラスをインスタンス化して利用しているため。
[import com.se.ren.Sample;]とするか[import com.se.ren.*;]とすれば正しくインポートが出来る

-------------------------------------------------------------------------------------------

２－１	B
long型には整数リテラルしかいれることができず、有働小数点リテラルが使用されているため。
C int c = 0777;		こちらは８進数の記述
D int d = 0xDeed; 	こちらは16進数の記述

分からなかった部分　８進数の記述　１６進数の記述

２－２　A　E
char型は1文字のリテラルしか扱うことが出来ず、''を用いて記述するため。
\uの後に４桁の整数（１６進数）を指定しており、Unicode値として扱われるため正しい。

分からなかった部分
\uの後の４桁はUnicodeの値として扱われるということ

２－３　B　F　G
B gotoは予約語であるため使用できない。
_と$は１文字目から使用可能な記号。
nullは予約語ではないが、リテラルである。
NULLの大文字は使用できない。
# ~ の記号は使用できない。

分からなかった部分
どの記号を識別子として使うことが出来なかったのか

２－４ C
val2はfinal識別子がついており定数となる。あとからの値の再代入は出来ないため。

２－５　B
array型のString配列は３つの要素数から構成されており、インデックスは0,1,2となる。
そのため、コンパイル自体は行えるが６行目で実行時エラーが起きる

ひっかけ問題に近い。

２－６　C
文字列のリテラルを+で結合した場合、計算は行われず、そのまま出力されるため。

間違い　正解はA
4行目以降のString型で作成した配列にint型の値を入れているため、コンパイルエラーが起きる。

原因　リテラルの見落とし ""で囲んだものはString型で扱われるが、囲まれていない数字は整数リテラルとして扱われるため。

２－７　C
配列の初期化を行い代入をしていないため
int型の配列は 0
boolean型の配列は false
String型の配列は nullで初期化される

補足　デフォルト値で初期化されている。

２－８　A

正解は B
原因は要素の見落とし
array[0][0] = a array[0][1] = b
array[1][0] = c array[1][1] = d
array[2][0] = e

２－９　A
コマンドライン引数で使用するargs[]はString型の配列を受け取るため、int型を記述するとコンパイルエラーが起きるため。

２－１０　E
"hello hello"は""にくくっているため一つの文字列としてargs[0]に格納され、そのまま連結されるため
hello hellobye　と表示される

２－１１　C
要素外の値を指定しているため、ArrayIndexOutOfBoundsException 例外が発生する。


２－１２　B　C
varを用いた記述では
var ary2 = new int[3] {};とするか
var ary3 = new int[3];　とする必要がある
var ary1 = {1, 2, 3};の記述はできない

補足
varを使用した配列の初期化では明示的な方が必要になるため。
var ary2 = new int[]のような要素数の指定がない場合もできない。

２－１３　E
すべてvarの文法として間違っているため。
メンバ変数には使用できない。
メソッドの引数には使用できない。
ローカル変数の宣言時に使用できるが、初期値の代入が必要
final修飾子ではvar宣言の左側に記述する必要がある。

var c;のみコンパイルができるが実行時エラーが発生する。

分からなかった部分
var宣言の理解

分からなかった部分総評
整数リテラル　８進数の記述　１６進数の記述
どの記号を識別子として使うことが出来なかったのか
var宣言の理解

---------------------------------------------------

３－１ C
3行目の9 + 1 + 2 は文字列 + 整数となっているため計算が行われたのちに文字列結合が行われる。よって答えは12
4行目は(9 + 1)がカッコで囲まれているため演算が行われたのちに文字列結合が行われる。

３－２　B
float ans = 7 / 6; // 1.0
７割る６の計算結果は1である。
計算結果は１になり、float型で宣言したansへ代入するため、暗黙の型変換が行われ1.0となる。

原因　演算　→　型変換の順番を理解しきれていなかった

３－３　C
int[]型で宣言した配列に異なった型を代入しているためコンパイルエラーとなる。

正解はB
char型をint型にする際は暗黙の型変換が行われるため。
値を代入する場合も型変換は適用される。

３－４　C
(11.00f == 1)の比較　trueが返るためコードは実行される
(123L != 123)の比較  !=で比較しており値が同じであるためfalseが返る

３－５　A　

正解はB
|| 演算子では片方がtrueであればもう片方の式は評価されない
よって(k-- < j)の式は評価されkの値は15となる。
&& 演算子は条件式がtrueでないため評価されるが、falseとなるため文の実行はされない。
よって最後の文が実行される。

３－６ E
条件演算子の結果がfalseとなるため
正解

原因　｜｜演算子が片方の条件式がtrueであればもう片方を評価しないということを忘れていた。

３－７　A B C
間違い

正解は A D F
switch文の式の結果は、データ型としてbyte、char、short、int,及びそのラッパークラス enum,Stringのいずれか

原因　switchで比較される型を理解しきれていなかった

３－８　F
間違い

正解はE
String str = "Orange";
switch(str) {
	case "orange";
		System.out.println("Orange");
	case "apple";
		System.out.println("Apple");
		break;
	default:
		System.out.println("default");
}
case式がないためdefault: の式が実行される

原因　switch文の文法を誤った理解の仕方をしていた
case 0: ←正解
case: 0 ←間違い

３－９　C
間違い

正解は　D
Integerは数値型であり、文字列型と比較しているためコンパイルエラーが起きる

原因　比較対象のデータ型が異なればエラーが起きるということを見落としていた

３－１０　C
間違い

正解は D
1 | 2としてあり|はビット演算子であるため。
ビットで比較し、どちらかが１のときのみは１を返し、それ以外は０を返す
1 → 0001
2 → 0010
結果 0011
よって３となり、default文も用意されていないので合致する文はなくなるため

原因　| 演算子の理解不足　ビットで比較されることを見落としていた。

３－１１　B
正解

String str1 = "Java";ではnewキーワードを使用していないため、Stringクラスが管理しているプールに文字列が配置される。
4行目ではnewキーワードによるインスタンス化を行っているため、別の文字列としが用意される。
== の比較演算子ではfalseが返り、equals()メソッドによる比較ではtrueが返る

３－１２　C
正解

3.String str1 = new String("Java");
4.String str2 = str1;
4行目では文字列の参照コピーが行われるため
==演算子で比較した場合同じ文字列を参照する
equalsで比較した場合もtrueが返る。

３－１３　A
間違い

正解はC
new　キーワードによるインスタンス化とそうでない場合の２つがあるので
str1 と str2の参照先は異なる str1 == str2 はfalse
intern()メソッドは、equals()メソッドによってこのStringオブジェクトに等しいと判定される文字列がプールに既にあった場合は、その文字列を返す。
new演算子でインスタンス化されたものはプール領域が違うため参照することができない。よってstr2が代入される。

原因intern()メソッドの理解

３－１４　C
replace()メソッドで呼び出しているが、置き換え後の文字列を再代入していないため同じ文字列が返る

原因 replace()メソッドの理解

３－１５ B
間違い

正解はC
StringBuilderで文字列をすべて削除するにはdeleteメソッドを使う
sb.delete(0, sb.length());

３－１６ A
分からない

３－１７　C
正解

３－１８　A
分からない

Stringクラスで生成した文字列は不変である
結果は戻り値で返るが、変数で受け取っていないため、文字列の変更はない

StringBuilderクラスで生成した文字列は変更が可能
StringBuilderでは変更後の文字列を返す。

----------------------------------------------
問題３－１　C
正解

問題３－２　B
正解

問題３－３　B
正解

問題３－４　C
正解

問題３－５　B
正解

問題３－６　E
正解

問題３－７　A、D、F
正解

問題３－８　E
正解

問題３－９　D
正解

問題３－１０　D
正解

問題３－１１　B
正解

問題３－１２　C
正解

問題３－１３　C
正解

問題３－１４　C
正解

問題３－１５　C
正解

問題３－１６　A
正解

問題３－１７　C
正解

問題３－１８　A
正解